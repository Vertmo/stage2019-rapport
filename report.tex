\documentclass{report}
\usepackage[a4paper, margin=1in]{geometry}

\usepackage[english]{babel}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}
\usepackage{graphicx}
\usepackage{shorttoc}
\usepackage{longtable}
\usepackage{listings,xcolor}
\usepackage{caption}
\usepackage{mathpartir}

\input{michelsonlang}

\title{Compiling a low-level language to Michelson}
\author{Basile Pesin,\\
  under the supervision of Bruno Bernardo,\\
  Nomadic Labs}

\begin{document}

\maketitle

\tableofcontents

\chapter*{Context}
\addcontentsline{toc}{chapter}{Context}

\section{The Tezos blockchain}

The Tezos ecosystem is centered around the Tezos blockchain. A blockchain is a decentralized database, usually focused on storing data about transactions made by it's users. Blockchains usually use a dedicated token, or cryptocurrency, to quantify these transactions. These currency, while they can't really (yet) be used to buy physical goods outside of the blockchain, can usually be exchanged for traditional government-established currencies, at varying rates. The currencies are often named the same as there related blockchains, and that's the case for Tezos (in the following report, I'll use ``Tezos'' for the blockchain, and ``tez'' (or ``XTZ'') for the related crypto-currency).\\

The Tezos blockchain, while currently an outsider compared to older, more successful blockchains (like Bitcoin or Ethereum), has several unique features that make it appealing. Namely, the chain gives token holders governance over the chain, being by using a proof-of-stake algorithm, or by allowing it's core protocol to be amended by votes of the community. More details on these features, which won't be discussed in this report, can be found in the Tezos White Paper~\cite{whitePaper}.

More to the point of this work, Tezos puts a strong emphasis on safety : the chain is implemented in OCaml, a statically typed programming language, which prevents some runtime errors. As we will see below, formal verification is also a focus on the work around the chain, and will be the focus of this report.

\section{The Michelson programming language}

Tezos, as well as allowing regular ``humans'' to create accounts (referred to as tz1 accounts), also allows users to run programs on the blockchain. These programs are often called ``smart contracts'', since most of them are used to automate transactions between two parties. Once the contract has been uploaded (originated) on the blockchain, it can then be called by any other account (being a human user or another smart-contract) by sending a transaction, containing at least a small amount of tez to cover processing fees, as well as the parameters of the contract. The contract itself holds a balance and can use it's tokens to forge it's own transactions.

The programming language used to write smart contracts for Tezos is called Michelson~\cite{michelsonwhitedoc}. Michelson is a statically typed stack-based programming language, meaning that the programmer has to explicitly manipulate the typed stack of the interpreter, using low level instructions. Examples of Michelson contracts (and there specification) are available in section \ref{contractsSpec}

As Michelson is a low level language, it can be very tedious to write: to manipulate the stack explicitly, the programmer needs to keep in mind the state of the stack at every point in the program (fortunately an emacs michelson-mode exists to display such information). The language was purposefully designed to be simple, which makes it easy to specify and proof specifications of programs, as we'll see below. However, it also makes writing smart-contracts in Michelson a bit tedious, and creates a barrier to entry for new programmers wanting to work in the Tezos ecosystem.

Since the Michelson interpreter is already part of the Tezos protocol (and can only be changed by amendment and vote of the community), it's a good base to build upon : creating higher-level programming language that would compile to Michelson would facilitate the writing of smart-contracts. To accomplish this goal, a first step will be to establish an intermediate programming language, Albert, abstracting away some of the low-level hurdles of Michelson (the stack manipulations in particular). To keep formal verification in mind, the Albert language semantics will be specified, and the compiler proved correct.

\chapter{The Mi-Cho-Coq framework}

The Mi-Cho-Coq project consists in a formalisation of Michelson's semantics, written in Coq. Coupled with a weakest-precondition calculation, it allows it's users to specify properties of Michelson programs, and to prove them using the Coq proof assistant. We'll see below a few proofs of relatively simple contracts.

\section{Proving the specification of smart-contracts}

\subsection{Weather insurance}
\label{contractsSpec}

The first contract we'll prove using Mi-Cho-Coq is the weather insurance contract. It's principle is simple : the contract is originated containing, in it's storage the addresses of two other accounts, a treshold of rain, and the public key of a third party oracle. The contract is also originated with a balance. At any point, the oracle can send an integer representing the actual level of rain, as well as it's signature. The contract then verifies that the signature is correct, and if it is, compares the level of rain with it's treshold : it then sends it's whole balance to one of the addresses saved in it's storage, depending on the level of rain relative to it's treshold.


\begin{lstlisting}[language=michelson]
parameter (pair (signature %received_sig) (nat :rain %rain_level));
storage (pair (pair (contract unit %under_addr)
                    (contract unit %over_addr))
              (pair (nat %rain_tresh) (key %weather_service_key)));
code { DUP; DUP;
       CAR; MAP_CDR{PACK ; BLAKE2B};
       SWAP; CDDDR;
       DIP {UNPAIR}; CHECK_SIGNATURE ; # Check if the data has been correctly signed
       ASSERT; # If signature is not correct, end the execution
       DUP; DUP; DUP; DIIIP{CDR}; # Place storage type on bottom of stack
       DIIP{CDAR};                # Place contracts below numbers
       DIP{CADR};   # Get actual rain
       CDDAR;         # Get rain threshold
       CMPLT; IF {CAR} {CDR};     # Select contract to receive tokens
       BALANCE; UNIT; TRANSFER_TOKENS; # Setup and execute transfer
       NIL operation; SWAP; CONS;
       PAIR };
\end{lstlisting}
Given the description above, we can easily give a specification of the contract. In the followings specifications, I'll note as ``preconditions'' the conditions that must be verified for the contract not to call \lstinline{FAIL} (or a related macro). The ``postconditions'' fully describe the new state of the storage at the end of the execution, as well as the potential generated operations.

{\small
\begin{longtable}{rl}
  \textbf{Preconditions}: & \texttt{SignatureCorrect}(weather\_service\_key, received\_sig)\\
  \textbf{Postconditions}: & new\_storage = storage\\
  & rain\_tresh $<$ rain\_level $\Rightarrow$ returned\_operations = [transfer\_tokens balance over\_addr]\\
  & rain\_tresh $\ge$ rain\_level $\Rightarrow$ returned\_operations = [transfer\_tokens balance under\_addr]\\
\end{longtable}}

Although this is a pretty simple specification that was pretty simple to prove, one point stands out : we only specify the production of the operations at the end of the contract, and not there effect (in this case, that the balance of the contract would be drained after any successful execution). This is because Mi-Cho-Coq only specifies the execution of the contract, and not the interactions exteriors to a single execution.

\subsection{Vote}

Another specified smart-contract is the Vote contract. As it's name implies, it allows users to vote for a candidate among a list set at origination. The contracts retains the number of votes towards each candidate. Any user can vote any number of time, but must send 5 tez (or $5000000\mu tez$) with each vote, otherwise the transaction is refused.

\begin{lstlisting}[language=michelson]
storage (map string int %candidates);
parameter string %chosen;
code { AMOUNT; PUSH mutez 5000000; COMPARE; GT;
       IF { FAIL } {};
       DUP; DIP { CDR; DUP }; CAR; DUP;
       DIP {
             GET; ASSERT_SOME;
             PUSH int 1; ADD; SOME
           };
       UPDATE; NIL operation; PAIR
     }
\end{lstlisting}

We can then specify this smart-contract as follows (\texttt{amount} refers to the quantity of $\mu tez$ sent by the caller for the transaction):
{\small
\begin{longtable}{rl}
  \textbf{Preconditions}: & \texttt{amount} $>$ 5000000\\
  & chosen $\in$ \texttt{Keys}(storage)\\
  \textbf{Postconditions}: & returned\_operations = [ ]\\
  & $\forall$ c, c $\in$ \texttt{Keys}(storage) $\iff$ c $\in$ \texttt{Keys}(new\_storage)\\
  & new\_storage[chosen] = storage[chosen] + 1\\
  & $\forall$ c $\in$ \texttt{Keys}(storage), c $\neq$ chosen $\Rightarrow$ new\_storage[c] = storage[c]
\end{longtable}}

Despite not looking much more complicated than the weather insurance smart contract, the specification of the vote smart-contract was slightly harder to prove. Indeed, in order to prove most of the postconditions, we had to prove a few lemmas on the map datastructure, and the relations between the functions ($mem$, $get$ and $update$) used to manipulate it. These lemmas were integrated in the library of Mi-Cho-Coq, and will most likely be useful to prove other contracts in the future.

%\subsection{List manipulations} TODO ?

\section{Tooling Michocott}

Michocott is an implementation of Mi-Cho-Coq, using the Ott~\cite{ottLang} programming language. From a set of grammar definitions and rules, Ott can generate typing and semantic rules for Coq (and other proof assistants), a menhir parser, as well as latex documentation.

\subsection{Documentation generation}

In order to adapt Ott to Michelson's needs, and especially the format of it's online documentation (\url{http://tezos.gitlab.io/mainnet/whitedoc/michelson.html}), which uses the ReStructuredText (reST) format, I added a reST output mode to Ott. Given the architecture of the Ott compiler, which separates frontend from backend pretty well, it was fairly easy to add a new RST backend.\\
To make the output practical for integrating pieces of the documentation with human-written text, I also added a mode allowing to generate one \textit{.rst} file per typing/semantic rule. The fragments can then be integrated into a single documentation page using the reST \texttt{.. include::} directive.\\

Another goal of automated document generation is to check that the typing and semantic rules specified in Michocott (and Mi-Cho-Coq) are indeed the same as the ones actually implemented in the Michelson interpreter running in the chain. In order to easily compare the two, we need a structured output which can be automatically generated from both Michocott and the interpreter. Luckily for us, on the interpreter side, we already have the start of a solution : Alexandre Doussot developped, for his own tool (try-michelson \url{https://gitlab.com/nomadic-labs/try-michelson}) a tool capable to parse the Michelson documentation (which, while not being automatically generated from the interpreter code, is kept updated and in check by the Tezos developers).

In order to complete the chain between the interpreter and Michocott, I added a JSON output to Ott. An example of the JSON output is as follows :
\lstset{
    string=[s]{"}{"},
    stringstyle=\color{blue},
    comment=[l]{:},
    commentstyle=\color{black},
}
\begin{lstlisting}
    {"op":"CDR",
      "ty":[{
         "name":"t_fun1_CDR",
         "premises":[],
         "conclusion":"CDR :: pair ty1 ty2 -> ty2"}],
      "semantics":[{
          "name":"bs_CDR",
          "premises":[],
          "conclusion":"CDR / ( Pair d d' ) : S => d' : S"}]
    },
\end{lstlisting}
The implementation of the output is unfortunately, highly specific to Michelson's need (in particular, it sorts and organize the rules according to the instruction they relate too), so it's very unlikely it will be merged into Ott proper, and will probably remain in a Nomadic-specific fork.

\subsection{Parser and lexer improvements}

In addition to it's specification and documentation capabilities, Ott can also, using the grammar rules defined for a language, generate both an Ocamllex lexer and a Menhir parser (only for OCaml, but a port to use the coq version of Menhir should be doable with minimal modifications). These functionalities however are still, in the main branch of Ott, a bit lackluster, and I proposed the following changes to fix some of the issues I encountered while using the lexer generation (these changes can be seen in this GitHub PR : \url{https://github.com/ott-lang/ott/pull/52})

\begin{itemize}
\item Order of the tokens : In order for the tokens to be correctly lexed, a token prefixing another must be placed after the longer token in the \textit{.mll} file : this is because OCamllex always select the first matching token it encounters, and therefore would always select the prefix if it was first in the list. Fortunately, it's sufficient to sort the tokens by decreasing length to solve this problem. More difficult is the problem of regular expressions that can be included in one another. I decided to simply place the metavars (which are most likely to use regex) at the end of the list; a better method could surely be implemented to construct topological sort of regex, but this would really complicate the program and the running time of Ott, for really small benefits.
\item Type conversion : Regarding the metavars, some of them are often used to define a token containing a value of a type different than string (typically, to parse integer or floats). The lexer generation didn't account for this, so I added a feature to automatically add a \texttt{string\_of\_XXX} conversion to the token lexing. The features get the relevant type from the metavar declaration in the Ott source file. As of this PR, I've only added the conversions \texttt{string\_of\_int}, \texttt{string\_of\_bool} and \texttt{string\_of\_float}, but it could be interesting allowing users to define and use their own conversion arbitrary conversion function (however, that would require some heavier modification of the code, and most likely be a really niche feature)
\item Location : Finally, I completed the calculations of lexer locations, which didn't update when uncountering a new line (``\textbackslash n'' character), because the call to \texttt{Lexing.new\_line lexbuf} was missing. This is a tiny change, but it allows for parsing error message to be correct and helpful.
\end{itemize}

\chapter{The Albert Programming Language}

\section{Overview}

Albert is a higher-level programming language than Michelson~\cite{albertProposal}. The main difference with Michelson is that, in Albert, the stack is abstracted by a record with named variables, which makes their manipulations easier. The variables in the main ``stack'' record are handled linearly, which means they are consumed when used, and must be explicitly duplicated if they need to be used twice. This reflects Michelson's behaviour, where values on the stack are indeed consumed by instructions using them.\\

The linear typing is handled by Albert's typing rules, which keeps tracks of the content of the stack (without it's ordering) at any point during the execution. For instance, below is a type of an instruction that assigns the value contained in a variable \texttt{foo} to a variable \texttt{bar}.

$$
\inferrule*
    { }
    { \Gamma \vdash bar = foo : \{ foo : ty \} @ rty \Rightarrow \{ bar : ty \} @ rty }
$$

Where \texttt{rty} is the type of the other values contained in the stack, and \texttt{@} denotes the join operation for record types. The semantics of this simple assign operation mirrors it's typing:

$$
\inferrule*
    { }
    { E \vdash bar = foo / \{ foo = val \} @ rval \rightarrow \{ bar = val \} @ rval }
    $$

\subsection{Types}

In order to fully utilize the possibilities of Michelson, Albert implements all the basic types implemented by michelson, that is : \texttt{int}, \texttt{nat}, \texttt{mutez}, \texttt{timestamp} for numeric types, \texttt{string} and \texttt{bytes}. Albert also implements the same data structures as Michelson, \texttt{list}, \texttt{set} and \texttt{map}.
    
Moreover, Albert generalizes \texttt{pair} types with \texttt{record}, and \texttt{or}, \texttt{option} and \texttt{bool} by n-ary \texttt{variant} with arbitrary constructors. For ease of use, Albert also adds these specific types to it's core language, making them equivalent to the similar record type (for instance, \texttt{option ty} is equivalent to the variant \texttt{[None : unit | Some : ty]}).

\subsection{Example smart-contract}

Below is the classic vote smart-contract, rewritten in Albert. It's notable that although the code is clearly longer than the Michelson one, it's also more comprehensible from an imperative programming frame of mind.

\begin{lstlisting}[language=caml].
type storage_ty = { threshold : mutez; votes: map string nat }

def vote :
   { store : storage_ty ; param : string } ->
   { operations : list operation ; out_storage : storage_ty } =

    (store0; store1) = dup store;
    threshold = store1.threshold;
    { car = threshold; cdr = threshold_copy } = dup threshold;
    ok = amount < threshold;
    match ok with
       True -> state = store0.votes ;
               { car = state0; cdr = state1 } = dup state;
               { car = param0; cdr = param1 } = dup param;
               prevote_option = state1[param1];
               prevote = assert_some prevote_option;
               one = 1;
               postvote = prevote + one;
               postvote = Some postvote;
               final_state = { state0 with param0 |-> postvote };
               out_storage = { votes = final_state; threshold = threshold_copy };
               operations = []
     | False ->
               failwith "you're so cheap!"
    end
\end{lstlisting}

Two difficulties still arise from writing an Albert contract, and create verbosity : first, the need to constantly assign every intermediate value to a variables, and second, the need to explicitly duplicate each resource the program has to use twice. These are unfortunately necessary in order to keep Albert's resource management close to Michelson's stack based management.

\section{Formal semantics}

Most of the language is actually based on the \texttt{lhs} = \texttt{rhs} assignment instruction, which is necessary to ensure all calculated values are indeed named and stored. Therefore an Albert program resembles a series of assignments, with the left-hand side being either a simple variable, or a record destructuring. We'll note below the formal semantics of these two left-hand sides.

$$
\inferrule* [left=(lhs\_var)]
    { }
    { E \vdash var / val \rightarrow \{ var = val \} }
$$

$$
\inferrule* [left=(lhs\_record)]
    { }
    { E \vdash \{ l_1 = x_1 ; .. ; l_n = x_n \} / \{ l_1 = val_1 ; .. ; l_n = val_n \} \rightarrow \{ x_1 = val_1 ; .. ; x_n = val_n \} }
$$

Actual calculations are performed in the right-hand side of assignment instructions. They can be either simple arguments (which we'll see below), function applications, primitive calculations, or specific calculations on data structures.

TODO

\section{Compiler to Mi-Cho-Coq}

\bibliography{biblio}{}
\bibliographystyle{unsrt}
\addcontentsline{toc}{chapter}{Bibliography}

\end{document}
